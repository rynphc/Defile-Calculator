<!DOCTYPE html>
<html>
  <head>
    <title></title>
  </head>

  <body>
    <script>
      const minionNum = {
        player: 3,
        opponent: 2
      };


      class Minion {
        constructor(health, divineShield, spellDamage, deathrattle) {
          this.health = health;
          this.divineShield = divineShield;
          this.spellDamage = spellDamage;
          this.deathrattle = deathrattle
        }
        toPrintableString() {
          return `health: ${this.health}, divineShield: ${this.divineShield}, spellDamage: ${this.spellDamage}`;
        }
        hasDivineShield() {
          return this.divineShield;
        }
      }

      class Battlefield {
        constructor(name) {
          this.name = name;
          this.minions = [];
          this.boardSpellDamage = 0;
        }
        generateTestingMinions(minionNum) {
          for(let i = 0; i < minionNum; i++) {
            let randomHealth = Math.floor(Math.random() * 10 + 1),
                randomDivineShield = Math.floor(Math.random() * 2),
                randomSpellDamage = Math.floor(Math.random() * 2);
            this.minions.push(new Minion(randomHealth, randomDivineShield, randomSpellDamage, 0));
          }
        }
        printMinions() {
          console.log(`${this.name}'s minions:`);
          if(this.minions.length == 0) {
            console.log('<empty>');
          } else {
            for(let i = 0; i < this.minions.length; i++)
              console.log(`(${i}) ${this.minions[i].toPrintableString()}`);
          }
        }
        updateBoardSpellDamage() {
          this.boardSpellDamage = 0;
          for(let i = 0; i < this.minions.length; i++)
            this.boardSpellDamage += this.minions[i].spellDamage;
        }
        dealDamagesToMinions(damage) {
          for(let i = 0; i < this.minions.length; i++) {
            let minion = this.minions[i];
            if(minion.hasDivineShield()) {
              minion.divineShield = 0;
            } else {
              this.minions[i].health -= damage;
            }
          }
        }
        updateMinionsState() {
          if(this.minions.length == 0) return 0;

          let numOfMinionsDied = 0;
          for(let i = 0; i < this.minions.length; i++) {
            if(this.minions[i].health <= 0) {
              numOfMinionsDied += 1;
              this.minions.splice(i, 1);
              i--;
            }
          }
          return numOfMinionsDied;
        }
      }

      let Snapshot = new class {
        constructor() {
          this.data = [];
        }
        make(_turn, _playerMinions, _opponentMinions, _boardSpellDamage) {
          this.data.push({
            turn: _turn,
            minions: {
              // Making deep copy
              player: JSON.parse(JSON.stringify(_playerMinions)),
              opponent: JSON.parse(JSON.stringify(_opponentMinions))
            },
            boardSpellDamage: _boardSpellDamage
          });
        }
      };

      /* ==================================================================== */

      let playerBattlefield = new Battlefield('Player'),
          opponentBattlefield = new Battlefield('Opponent');

      playerBattlefield.generateTestingMinions(minionNum.player);
      playerBattlefield.printMinions();

      opponentBattlefield.generateTestingMinions(minionNum.opponent);
      opponentBattlefield.printMinions();

      playerBattlefield.updateBoardSpellDamage();
      Snapshot.make(0,
        playerBattlefield.minions,
        opponentBattlefield.minions,
        playerBattlefield.boardSpellDamage
      );

      /* ==================================================================== */

      let keepCasting = false,
          timesOfCasting = 0;
      do {
         keepCasting = castDefileOnce();
      } while(keepCasting);

      function castDefileOnce() {
        let numOfMinionsDied = 0;

        timesOfCasting++;
        playerBattlefield.updateBoardSpellDamage();
        console.log(`\nCast defile (${timesOfCasting} times), boardSpellDamage: ${playerBattlefield.boardSpellDamage}`);

        playerBattlefield.dealDamagesToMinions(1 + playerBattlefield.boardSpellDamage);
        numOfMinionsDied += playerBattlefield.updateMinionsState();
        playerBattlefield.printMinions();

        opponentBattlefield.dealDamagesToMinions(1 + opponentBattlefield.boardSpellDamage);
        numOfMinionsDied += opponentBattlefield.updateMinionsState();
        opponentBattlefield.printMinions();

        console.log(`num of minions died this turn: ${numOfMinionsDied}`)

        Snapshot.make(timesOfCasting,
          playerBattlefield.minions,
          opponentBattlefield.minions,
          playerBattlefield.boardSpellDamage
        );

        return numOfMinionsDied;
      };
    </script>
  </body>
</html>
